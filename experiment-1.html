<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Experiment 1 – Mobile Hand Magic</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
html, body {
  margin: 0;
  padding: 0;
  background: #000;
  overflow: hidden;
  font-family: system-ui;
  touch-action: none;
}

canvas {
  position: fixed;
  inset: 0;
}

/* Popup */
#popup {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle, #111, #000);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

.popup-box {
  background: #111;
  color: white;
  padding: 32px 40px;
  border-radius: 18px;
  text-align: center;
  box-shadow: 0 0 40px rgba(0,255,255,0.3);
  position: relative;
}

.popup-box h1 {
  font-size: 22px;
  font-weight: 500;
  background: linear-gradient(90deg,#ff7af5,#7afcff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

#closeBtn {
  position: absolute;
  top: 10px;
  right: 14px;
  font-size: 20px;
  background: none;
  border: none;
  color: white;
}

#hint {
  position: fixed;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  color: #0ff;
  font-size: 13px;
  opacity: 0.8;
}

video { display: none; }
</style>
</head>

<body>

<div id="popup">
  <div class="popup-box">
    <button id="closeBtn">✕</button>
    <h1>Show hand gesture to see magic</h1>
  </div>
</div>

<div id="hint">Move hand or touch screen</div>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ---------- MOBILE DETECTION ---------- */
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

/* ---------- THREE SETUP ---------- */
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
const camera3D = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 400);
camera3D.position.z = 110;

/* ---------- PARTICLES ---------- */
const COUNT = 3500; // mobile-safe
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(COUNT*3);
const col = new Float32Array(COUNT*3);

let shapeIndex = 0;

function makeShape(type){
  for(let i=0;i<COUNT;i++){
    let t = Math.random()*Math.PI*2;
    let r = Math.random()*30;
    let x=0,y=0,z=0;

    if(type===0){ // Heart
      x = 14*Math.pow(Math.sin(t),3);
      y = 11*Math.cos(t)-4*Math.cos(2*t);
      z = (Math.random()-0.5)*8;
    }
    else if(type===1){ // Ring
      x = Math.cos(t)*r;
      y = Math.sin(t)*r*0.3;
      z = Math.sin(t)*r;
    }
    else{ // Cloud
      x=(Math.random()-0.5)*70;
      y=(Math.random()-0.5)*70;
      z=(Math.random()-0.5)*70;
    }

    pos[i*3]=x;
    pos[i*3+1]=y;
    pos[i*3+2]=z;

    col[i*3]=Math.random();
    col[i*3+1]=Math.random();
    col[i*3+2]=Math.random();
  }
  geo.attributes.position.needsUpdate=true;
}

geo.setAttribute("position",new THREE.BufferAttribute(pos,3));
geo.setAttribute("color",new THREE.BufferAttribute(col,3));
makeShape(0);

const mat = new THREE.PointsMaterial({
  size: 1.9,
  vertexColors:true,
  blending: THREE.NormalBlending
});

const points = new THREE.Points(geo,mat);
scene.add(points);

/* ---------- CONTROL VARIABLES ---------- */
let targetX=0, targetY=0;
let scale=1;
let lastSwitch=0;

/* ---------- HAND TRACKING ---------- */
const hands = new Hands({
  locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands:1,
  modelComplexity:0,
  minDetectionConfidence:0.6,
  minTrackingConfidence:0.6
});

hands.onResults(res=>{
  if(!res.multiHandLandmarks) return;

  const lm = res.multiHandLandmarks[0];
  targetX = (lm[9].x-0.5)*180;
  targetY = (0.5-lm[9].y)*180;

  const pinch = Math.abs(lm[4].x-lm[8].x);
  scale = THREE.MathUtils.clamp(pinch*6,0.9,3);

  const now = performance.now();
  if(pinch>0.28 && now-lastSwitch>1000){
    shapeIndex=(shapeIndex+1)%3;
    makeShape(shapeIndex);
    lastSwitch=now;
  }
});

/* ---------- TOUCH FALLBACK ---------- */
let touchMode=false;

addEventListener("touchstart",e=>{
  touchMode=true;
  targetX=(e.touches[0].clientX/innerWidth-0.5)*200;
  targetY=(0.5-e.touches[0].clientY/innerHeight)*200;
});

addEventListener("touchmove",e=>{
  targetX=(e.touches[0].clientX/innerWidth-0.5)*200;
  targetY=(0.5-e.touches[0].clientY/innerHeight)*200;
});

/* ---------- CAMERA ---------- */
const video=document.getElementById("video");
let cam;

document.getElementById("closeBtn").onclick=()=>{
  document.getElementById("popup").style.display="none";

  cam=new Camera(video,{
    onFrame:async()=>await hands.send({image:video}),
    width:480,
    height:360
  });

  cam.start();
  animate();
};

/* ---------- LOOP ---------- */
function animate(){
  requestAnimationFrame(animate);

  points.position.x += (targetX-points.position.x)*0.1;
  points.position.y += (targetY-points.position.y)*0.1;

  mat.size=scale*2;
  points.rotation.y+=0.002;

  renderer.render(scene,camera3D);
}

onresize=()=>{
  camera3D.aspect=innerWidth/innerHeight;
  camera3D.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
};
</script>

</body>
</html>
