<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Experiment 1</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        canvas { display: block; touch-action: none; }

        #popup-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; padding: 20px; box-sizing: border-box;
        }

        #guidance-pop {
            position: relative;
            background: #1a1a2e;
            padding: 30px; border-radius: 25px;
            text-align: center; color: white;
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px; width: 100%;
        }

        #guidance-pop h2 { margin: 0; font-weight: 400; font-size: 1.5rem; }
        #guidance-pop p { color: #00d4ff; margin: 15px 0 25px; font-size: 1rem; }

        #close-btn {
            position: absolute; top: 15px; right: 15px;
            background: #333; border: none; color: white;
            width: 30px; height: 30px; border-radius: 50%;
            font-size: 18px; cursor: pointer;
        }

        #video-input { display: none; }
        
        /* Loading indicator for mobile data */
        #loader {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%); color: rgba(255,255,255,0.5);
            font-size: 12px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="popup-overlay">
        <div id="guidance-pop">
            <button id="close-btn">✕</button>
            <h2>Experiment 1</h2>
            <p>Show hand gesture to see magic</p>
            <small style="opacity: 0.6">Use front camera in a bright room</small>
        </div>
    </div>

    <div id="loader">Initializing Camera...</div>
    <video id="video-input" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
let scene, camera, renderer, particles, geometry;
const particleCount = 6000;
let targetPositions = [];
let currentShapeIndex = 0;
const videoElement = document.getElementById('video-input');

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    document.body.appendChild(renderer.domElement);

    geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 10;
        colors[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.04,
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    createShapes();
    animate();
}

function createShapes() {
    targetPositions = [
        getSphereData(),
        getHeartData(),
        getSaturnData(),
        getInfinityData()
    ];
}

/* ---- SHAPE FUNCTIONS UNCHANGED ---- */
function getSphereData() { /* same as yours */ 
    const arr = new Float32Array(particleCount * 3);
    for(let i=0;i<particleCount;i++){
        const phi=Math.acos(-1+(2*i)/particleCount);
        const theta=Math.sqrt(particleCount*Math.PI)*phi;
        arr[i*3]=2.5*Math.cos(theta)*Math.sin(phi);
        arr[i*3+1]=2.5*Math.sin(theta)*Math.sin(phi);
        arr[i*3+2]=2.5*Math.cos(phi);
    }
    return arr;
}

function getHeartData() {
    const arr = new Float32Array(particleCount * 3);
    for(let i=0;i<particleCount;i++){
        const t=Math.random()*Math.PI*2;
        arr[i*3]=0.18*(16*Math.pow(Math.sin(t),3));
        arr[i*3+1]=0.18*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
        arr[i*3+2]=(Math.random()-0.5)*0.5;
    }
    return arr;
}

function getSaturnData() {
    const arr = new Float32Array(particleCount * 3);
    for(let i=0;i<particleCount;i++){
        if(i<particleCount*0.4){
            const r=Math.random()*1.5;
            const th=Math.random()*Math.PI*2;
            const ph=Math.random()*Math.PI;
            arr[i*3]=r*Math.sin(ph)*Math.cos(th);
            arr[i*3+1]=r*Math.sin(ph)*Math.sin(th);
            arr[i*3+2]=r*Math.cos(ph);
        } else {
            const r=2.8+Math.random()*1.2;
            const th=Math.random()*Math.PI*2;
            arr[i*3]=r*Math.cos(th);
            arr[i*3+1]=(Math.random()-0.5)*0.3;
            arr[i*3+2]=r*Math.sin(th);
        }
    }
    return arr;
}

function getInfinityData() {
    const arr = new Float32Array(particleCount * 3);
    for(let i=0;i<particleCount;i++){
        const t=(i/particleCount)*Math.PI*2;
        const s=3.5/(3-Math.cos(2*t));
        arr[i*3]=s*Math.cos(t);
        arr[i*3+1]=s*Math.sin(2*t)/2;
        arr[i*3+2]=(Math.random()-0.5)*0.5;
    }
    return arr;
}

function morphTo(index) {
    const posAttr = geometry.attributes.position;
    const target = targetPositions[index];

    gsap.to(posAttr.array, {
        endArray: target,
        duration: 1.4,
        ease: "power2.out",
        onUpdate: () => posAttr.needsUpdate = true
    });

    const colAttr = geometry.attributes.color;
    const h = (index * 90) % 360;
    const c = new THREE.Color(`hsl(${h},80%,60%)`);
    for(let i=0;i<particleCount;i++){
        colAttr.array[i*3]=c.r;
        colAttr.array[i*3+1]=c.g;
        colAttr.array[i*3+2]=c.b;
    }
    colAttr.needsUpdate=true;
}

/* ---- HAND TRACKING FIX ---- */
const hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 0,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6,
    selfieMode: true
});

let lastMorphTime = 0;

hands.onResults(res => {
    document.getElementById('loader').style.display = 'none';
    if(!res.multiHandLandmarks?.length) return;

    const hand = res.multiHandLandmarks[0];

    const x = (hand[8].x - 0.5) * -12;
    const y = (hand[8].y - 0.5) * -12;

    particles.position.x += (x - particles.position.x) * 0.15;
    particles.position.y += (y - particles.position.y) * 0.15;

    // ✅ PINCH GESTURE (STABLE ON MOBILE)
    const pinch = Math.abs(hand[4].x - hand[8].x);
    const now = Date.now();

    if (pinch < 0.035 && now - lastMorphTime > 1500) {
        currentShapeIndex = (currentShapeIndex + 1) % targetPositions.length;
        morphTo(currentShapeIndex);
        lastMorphTime = now;
    }
});

/* ---- CAMERA START FIX ---- */
const cameraFeed = new Camera(videoElement, {
    onFrame: async () => {
        if (videoElement.readyState >= 2) {
            await hands.send({ image: videoElement });
        }
    },
    facingMode: 'user',
    width: 480,
    height: 480
});

document.getElementById('close-btn').onclick = () => {
    document.getElementById('popup-overlay').style.display = 'none';
    initThree();
    cameraFeed.start();
};

function animate() {
    requestAnimationFrame(animate);
    particles.rotation.y += 0.005;
    renderer.render(scene, camera);
}

window.onresize = () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
};
</script>
</body>
</html>